## Проект: Concurrent Execution

Этот проект посвящён изучению конкурентности в Go через серию небольших, сфокусированных заданий.
Каждое задание помогает развить практическое понимание горутин, каналов, синхронизации, работы со временем и дженериков.

#### Цель проекта

Разобраться в модели конкурентности Go — как горутины взаимодействуют, синхронизируются и корректно завершаются.
Освоить управление временем выполнения: таймеры, тикеры, дедлайны.
Научиться грамотно завершать конкурентные процессы с помощью context и sync.WaitGroup.
Повысить осведомлённость о безопасности памяти и производительности при многопоточном выполнении.
Научиться применять дженерики Go для создания эффективных и переиспользуемых структур данных.

#### Задание 1. Секундомер для асинхронных задач

Цель: измерить время выполнения нескольких конкурентных задач.
Фокус: горутины, каналы, синхронизация, работа со временем, отмена операций.
Ожидаемый результат:
- Программа запускает несколько асинхронных заданий.
- После их завершения (или по истечении таймаута) выводится общее и индивидуальное время выполнения.
- Демонстрируется корректное завершение и использование WaitGroup или context.

#### Задание 2. Генератор квадратов чисел

Цель: построить конвейер (pipeline), который генерирует числа и вычисляет их квадраты.
Фокус: шаблон producer–consumer, работа с каналами, корректное завершение горутин.
Ожидаемый результат:
- Генератор последовательно выдаёт числа (до заданного предела или бесконечно).
- Потребитель читает их и выводит квадраты.
- После завершения не остаётся «зависших» горутин.

#### Задание 3. Тикер

Цель: реализовать выполнение периодических действий с использованием time.Ticker.
Фокус: планирование задач, циклы с таймингом, освобождение ресурсов.
Ожидаемый результат:
- Программа выполняет повторяющееся действие (например, вывод времени) каждые N секунд.
- Завершается корректно при получении сигнала или таймаута.
- Демонстрируется корректное использование ticker.Stop().

#### Задание 4. LRU-кэш с использованием дженериков

Цель: реализовать кэш с политикой «Least Recently Used» с применением дженериков Go.
Фокус: примитивы синхронизации (sync.Mutex, sync.Map), типизация с дженериками, безопасный конкурентный доступ.
Ожидаемый результат:
- Кэш автоматически удаляет наименее используемые элементы при превышении ёмкости.
- Одновременные операции чтения и записи выполняются безопасно.
- Структура универсальна и подходит для любых типов ключей и значений.